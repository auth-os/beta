pragma solidity ^0.4.20;

contract RegistryScriptExec {

  /// FUNCTION SELECTORS ///

  // Function selector for storage interface 'writeMulti'
  // writeMulti(address _storage, bytes32 _app_id, bytes32[] _input, address _requestor)
  bytes4 public constant WR_MULTI_SEL = bytes4(keccak256("writeMulti(address,bytes32,address,bytes32[])"));

  // Function selector for storage interface 'initApp'
  // initApp(address _storage, address[] _allowed) returns (bytes32 app_id)
  bytes4 public constant INIT_APP_SEL = bytes4(keccak256("initApp(address,address[])"));

  /// OTHER CONSTANTS ///

  // Constant value returned by a function which is returning data and does not need storage
  bytes32 public constant CONST_RETURN = bytes32(keccak256("const_return"));

  // Constant value returned by a function which requests storage
  bytes32 public constant REQUEST_STORAGE = bytes32(keccak256("request_storage"));

  /*
  Executes a passed-in script and stores the result in storage

  @param _app_id: The unique app id under which reads and writes are requested
  @param _storage_interface: The address through which storage reads and writes are made
  @param _abs_storage: The address where storage is located
  @param _target: The address to send the initial staticcall to. Returns a storage request, which is forwarded to the storage interface as a 'writeMulti' request
  @param _script: The script to execute - contains a target address, calldata size, and calldata in this format -
  [target_address][calldata size][calldata]
  */
  function execAndStore(bytes32 _app_id, address _storage_interface, address _abs_storage, address _target, bytes _script) public returns (bytes return_data) {
    // Place 'writeMulti' selector in memory
    bytes4 wr_multi_sel = WR_MULTI_SEL;
    // Place return data commands in memory
    bytes32 const_return = CONST_RETURN;
    bytes32 request_storage = REQUEST_STORAGE;
    assembly {
      // Call target with calldata
      let ret := staticcall(gas, _target, add(0x20, _script), mload(_script), 0, 0)
      // Read return value - if zero, call failed: revert
      if iszero(ret) { revert (0, 0) }
      // Read returned command
      let ret_cmd := mload(0x40)
      // First slot of return data is always a command
      returndatacopy(ret_cmd, 0, 0x20)
      // If the returned data signifies a constant return and no storage request, return the data
      if eq(mload(ret_cmd), const_return) {
        // Get space for return data
        return_data := add(0x20, msize)
        // Set length of return data
        mstore(return_data, sub(returndatasize, 0x20))
        // Copy returned data and return
        returndatacopy(add(0x20, return_data), 0x20, sub(returndatasize, 0x20))
      }
      // Check that the returned data is a storage request. If so, forward request to storage interface
      if eq(mload(ret_cmd), request_storage) {
        // Prepare 'writeMulti' call to storage interface

        // Get pointer to free memory for calldata
        let sel_ptr := mload(0x40)
        // Load 'writeMulti' function selector into calldata
        mstore(sel_ptr, wr_multi_sel)
        // Load storage address into calldata
        mstore(add(0x04, sel_ptr), _abs_storage)
        // Load app id into calldata
        mstore(add(0x24, sel_ptr), _app_id)
        // Load logic address into calldata
        mstore(add(0x44, sel_ptr), _target)
        // Load data read offset into calldata
        mstore(add(0x64, sel_ptr), 0x80)
        // Copy data from logic address return into calldata
        returndatacopy(add(0x84, sel_ptr), 0x20, sub(returndatasize, 0x20))

        // Forward returned data to storage interface
        ret := call(gas, _storage_interface, 0, sel_ptr, add(0x84, sub(returndatasize, 0x20)), 0, 0)
        // Read return value - if zero, call failed: revert
        if iszero(ret) { revert (0, 0) }
        // Get return value
        return_data := add(0x20, msize)
        // Set return size
        mstore(return_data, returndatasize)
        // Copy returned data and return
        returndatacopy(return_data, 0, returndatasize)
      }
    }
  }

  /*
  Initializes a registry application through a given storage interface, and returns the app id under which storage requests are made

  @param _storage_interface: The address through which storage reads and writes are made
  @param _abs_storage: The address where registry storage is located
  @param _allowed: An array of allowed addresses to use with this registry app
  @return app_id: An app id generated by the storage interface
  */
  function initRegistryApp(address _storage_interface, address _abs_storage, address[] _allowed) public returns (bytes32 app_id) {
    // Place 'initApp' function selector in memory
    bytes4 init_sel = INIT_APP_SEL;
    assembly {
      // Get pointer to free memory for calldata
      let sel_ptr := mload(0x40)
      // Store 'initApp' selector at pointer
      mstore(sel_ptr, init_sel)
      // Store storage address in calldata
      mstore(add(0x04, sel_ptr), _abs_storage)
      // Place data read offset in calldata
      mstore(add(0x24, sel_ptr), 0x40)
      // Use calldatacopy to copy _allowed from calldata into sel_ptr
      calldatacopy(add(0x44, sel_ptr), 0x64, add(0x20, mul(0x20, mload(_allowed))))
      // Call storage interface and store return at sel_ptr
      let ret := call(gas, _storage_interface, 0, sel_ptr, add(0x64, mul(0x20, mload(_allowed))), sel_ptr, 0x20)
      // Read return value - if zero, call failed: revert
      if iszero(ret) { revert (0, 0) }
      // If returned app id is zero, revert
      if iszero(mload(sel_ptr)) { revert (0, 0) }
      // Return app id
      app_id := mload(sel_ptr)
    }
  }
}
